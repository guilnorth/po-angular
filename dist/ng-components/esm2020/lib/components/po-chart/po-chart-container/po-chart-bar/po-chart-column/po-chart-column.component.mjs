import { Component } from '@angular/core';
import { PoChartPlotAreaPaddingTop } from '../../../helpers/po-chart-default-values.constant';
import { PoChartBarBaseComponent } from '../po-chart-bar-base.component';
import * as i0 from "@angular/core";
import * as i1 from "../../../services/po-chart-maths.service";
import * as i2 from "@angular/common";
import * as i3 from "../po-chart-bar-path/po-chart-bar-path.component";
const _c0 = ["po-chart-column", ""];
function PoChartColumnComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "g")(1, "g", 1);
    i0.ɵɵlistener("p-bar-click", function PoChartColumnComponent__svg_g_1_Template__svg_g_p_bar_click_1_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r3 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r3.onSerieBarClick($event)); })("p-bar-hover", function PoChartColumnComponent__svg_g_1_Template__svg_g_p_bar_hover_1_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r5 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r5.onSerieBarHover($event)); });
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassMap("po-chart-bar-group-" + i_r2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("p-color", item_r1[0] == null ? null : item_r1[0].color)("p-coordinates", item_r1)("p-tooltip-position", ctx_r0.tooltipPosition);
    i0.ɵɵattribute("key", "po-chart-bar-path-" + i_r2);
} }
export class PoChartColumnComponent extends PoChartBarBaseComponent {
    constructor(mathsService) {
        super(mathsService);
        this.mathsService = mathsService;
        this.tooltipPosition = 'top';
    }
    barCoordinates(seriesIndex, serieItemDataIndex, containerSize, minMaxSeriesValues, serieValue) {
        const { svgWidth, axisXLabelWidth, svgPlottingAreaHeight } = containerSize;
        const { chartBarPlotArea, barWidth, spaceBetweenBars } = this.calculateElementsMeasurements(svgWidth, axisXLabelWidth);
        const { x1, x2 } = this.xCoordinates(seriesIndex, serieItemDataIndex, chartBarPlotArea, barWidth, spaceBetweenBars, axisXLabelWidth);
        const { y1, y2 } = this.yCoordinates(minMaxSeriesValues, svgPlottingAreaHeight, serieValue);
        return ['M', x1, y2, 'L', x2, y2, 'L', x2, y1, 'L', x1, y1, 'z'].join(' ');
    }
    calculateElementsMeasurements(svgWidth, axisXLabelWidth) {
        // Fração das séries em relação à largura da categoria. Incrementa + 2 na extensão das séries pois se trata da área de margem entre as categorias.
        const chartBarPlotArea = svgWidth - axisXLabelWidth;
        const categoryWidth = chartBarPlotArea / this.seriesGreaterLength;
        const columnFraction = categoryWidth / (this.series.length + 2);
        // Área entre as colunas: retorna zero se houver apenas uma série.
        const spaceBetweenBars = this.series.length > 1 ? columnFraction / (this.series.length + 2) : 0;
        // Subtrai a fração das séries pelo espaço entre as colunas.
        const barWidth = columnFraction - (spaceBetweenBars * (this.series.length - 1)) / (this.series.length + 2);
        return { chartBarPlotArea, barWidth, spaceBetweenBars };
    }
    xCoordinates(seriesIndex, serieItemDataIndex, chartBarPlotArea, barWidth, spaceBetweenBars, axisXLabelWidth) {
        // A área lateral entre a coluna e a linha do eixo Y do grid será sempre equivalente à largura da coluna.
        const spaceBetweenAxisAndBars = barWidth;
        const xRatio = serieItemDataIndex / this.seriesGreaterLength;
        const x1 = Math.round(axisXLabelWidth +
            chartBarPlotArea * xRatio +
            spaceBetweenAxisAndBars +
            barWidth * seriesIndex +
            spaceBetweenBars * seriesIndex);
        const x2 = Math.round(x1 + barWidth);
        return { x1, x2 };
    }
    yCoordinates(minMaxSeriesValues, svgPlottingAreaHeight, serieValue) {
        const { minValue } = minMaxSeriesValues;
        const minValuePercentage = this.mathsService.getSeriePercentage(minMaxSeriesValues, minValue < 0 ? 0 : minValue);
        const y1 = Math.round(svgPlottingAreaHeight - svgPlottingAreaHeight * minValuePercentage + PoChartPlotAreaPaddingTop);
        const yRatio = this.mathsService.getSeriePercentage(minMaxSeriesValues, serieValue);
        const y2 = Math.round(svgPlottingAreaHeight - svgPlottingAreaHeight * yRatio + PoChartPlotAreaPaddingTop);
        return { y1, y2 };
    }
}
PoChartColumnComponent.ɵfac = function PoChartColumnComponent_Factory(t) { return new (t || PoChartColumnComponent)(i0.ɵɵdirectiveInject(i1.PoChartMathsService)); };
PoChartColumnComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: PoChartColumnComponent, selectors: [["", "po-chart-column", ""]], features: [i0.ɵɵInheritDefinitionFeature], attrs: _c0, decls: 2, vars: 2, consts: [[3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["po-chart-bar-path", "", 3, "p-color", "p-coordinates", "p-tooltip-position", "p-bar-click", "p-bar-hover"]], template: function PoChartColumnComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵnamespaceSVG();
        i0.ɵɵelementStart(0, "g");
        i0.ɵɵtemplate(1, PoChartColumnComponent__svg_g_1_Template, 2, 6, "g", 0);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.seriesPathsCoordinates)("ngForTrackBy", ctx.trackBy);
    } }, dependencies: [i2.NgForOf, i3.PoChartBarPathComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PoChartColumnComponent, [{
        type: Component,
        args: [{ selector: '[po-chart-column]', template: "<svg:g>\r\n  <svg:g *ngFor=\"let item of seriesPathsCoordinates; let i = index; trackBy: trackBy\"\r\n    [class]=\"'po-chart-bar-group-' + i\"\r\n  >\r\n    <!-- SERIES PATHS -->\r\n    <svg:g po-chart-bar-path\r\n      [attr.key]=\"'po-chart-bar-path-' + i\"\r\n      [p-color]=\"item[0]?.color\" \r\n      [p-coordinates]=\"item\"\r\n      [p-tooltip-position]=\"tooltipPosition\"\r\n      (p-bar-click)=\"onSerieBarClick($event)\"\r\n      (p-bar-hover)=\"onSerieBarHover($event)\"\r\n      >\r\n      </svg:g>\r\n  </svg:g>\r\n</svg:g>" }]
    }], function () { return [{ type: i1.PoChartMathsService }]; }, null); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tY2hhcnQtY29sdW1uLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3VpL3NyYy9saWIvY29tcG9uZW50cy9wby1jaGFydC9wby1jaGFydC1jb250YWluZXIvcG8tY2hhcnQtYmFyL3BvLWNoYXJ0LWNvbHVtbi9wby1jaGFydC1jb2x1bW4uY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvdWkvc3JjL2xpYi9jb21wb25lbnRzL3BvLWNoYXJ0L3BvLWNoYXJ0LWNvbnRhaW5lci9wby1jaGFydC1iYXIvcG8tY2hhcnQtYmFyLmNvbXBvbmVudC5zdmciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUxQyxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxtREFBbUQsQ0FBQztBQUU5RixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQzs7Ozs7Ozs7O0lDSHZFLHlCQUVDLFdBQUE7SUFPRyx3TEFBZSxlQUFBLDhCQUF1QixDQUFBLElBQUMsMktBQ3hCLGVBQUEsOEJBQXVCLENBQUEsSUFEQztJQUd2QyxpQkFBUSxFQUFBOzs7OztJQVhWLDJDQUFtQztJQUtqQyxlQUEwQjtJQUExQixzRUFBMEIsMEJBQUEsOENBQUE7SUFEMUIsa0RBQXFDOztBRFEzQyxNQUFNLE9BQU8sc0JBQXVCLFNBQVEsdUJBQXVCO0lBR2pFLFlBQXNCLFlBQWlDO1FBQ3JELEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztRQURBLGlCQUFZLEdBQVosWUFBWSxDQUFxQjtRQUY5QyxvQkFBZSxHQUFHLEtBQUssQ0FBQztJQUlqQyxDQUFDO0lBRVMsY0FBYyxDQUN0QixXQUFtQixFQUNuQixrQkFBMEIsRUFDMUIsYUFBbUMsRUFDbkMsa0JBQXVDLEVBQ3ZDLFVBQWtCO1FB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a0IsRUFBRSxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2pILE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQ25CLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLHlCQUF5QixDQUMvRixDQUFDO1FBRUYsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxrQkFBa0IsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNwRixNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLE1BQU0sR0FBRyx5QkFBeUIsQ0FBQyxDQUFDO1FBRTFHLE9BQU8sRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7SUFDcEIsQ0FBQzs7NEZBdkZVLHNCQUFzQjt5RUFBdEIsc0JBQXNCO1FDZG5DLG1CQUFPO1FBQVAseUJBQU87UUFDTCx3RUFhUTtRQUNWLGlCQUFROztRQWRrQixlQUEyQjtRQUEzQixvREFBMkIsNkJBQUE7O3VGRGF4QyxzQkFBc0I7Y0FKbEMsU0FBUzsyQkFDRSxtQkFBbUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7IFBvQ2hhcnRQbG90QXJlYVBhZGRpbmdUb3AgfSBmcm9tICcuLi8uLi8uLi9oZWxwZXJzL3BvLWNoYXJ0LWRlZmF1bHQtdmFsdWVzLmNvbnN0YW50JztcclxuXHJcbmltcG9ydCB7IFBvQ2hhcnRCYXJCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vcG8tY2hhcnQtYmFyLWJhc2UuY29tcG9uZW50JztcclxuaW1wb3J0IHsgUG9DaGFydE1hdGhzU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZpY2VzL3BvLWNoYXJ0LW1hdGhzLnNlcnZpY2UnO1xyXG5cclxuaW1wb3J0IHsgUG9DaGFydENvbnRhaW5lclNpemUgfSBmcm9tICcuLi8uLi8uLi9pbnRlcmZhY2VzL3BvLWNoYXJ0LWNvbnRhaW5lci1zaXplLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IFBvQ2hhcnRNaW5NYXhWYWx1ZXMgfSBmcm9tICcuLi8uLi8uLi9pbnRlcmZhY2VzL3BvLWNoYXJ0LW1pbi1tYXgtdmFsdWVzLmludGVyZmFjZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ1twby1jaGFydC1jb2x1bW5dJyxcclxuICB0ZW1wbGF0ZVVybDogJy4uL3BvLWNoYXJ0LWJhci5jb21wb25lbnQuc3ZnJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgUG9DaGFydENvbHVtbkNvbXBvbmVudCBleHRlbmRzIFBvQ2hhcnRCYXJCYXNlQ29tcG9uZW50IHtcclxuICByZWFkb25seSB0b29sdGlwUG9zaXRpb24gPSAndG9wJztcclxuXHJcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIG1hdGhzU2VydmljZTogUG9DaGFydE1hdGhzU2VydmljZSkge1xyXG4gICAgc3VwZXIobWF0aHNTZXJ2aWNlKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBiYXJDb29yZGluYXRlcyhcclxuICAgIHNlcmllc0luZGV4OiBudW1iZXIsXHJcbiAgICBzZXJpZUl0ZW1EYXRhSW5kZXg6IG51bWJlcixcclxuICAgIGNvbnRhaW5lclNpemU6IFBvQ2hhcnRDb250YWluZXJTaXplLFxyXG4gICAgbWluTWF4U2VyaWVzVmFsdWVzOiBQb0NoYXJ0TWluTWF4VmFsdWVzLFxyXG4gICAgc2VyaWVWYWx1ZTogbnVtYmVyXHJcbiAgKSB7XHJcbiAgICBjb25zdCB7IHN2Z1dpZHRoLCBheGlzWExhYmVsV2lkdGgsIHN2Z1Bsb3R0aW5nQXJlYUhlaWdodCB9ID0gY29udGFpbmVyU2l6ZTtcclxuICAgIGNvbnN0IHsgY2hhcnRCYXJQbG90QXJlYSwgYmFyV2lkdGgsIHNwYWNlQmV0d2VlbkJhcnMgfSA9IHRoaXMuY2FsY3VsYXRlRWxlbWVudHNNZWFzdXJlbWVudHMoXHJcbiAgICAgIHN2Z1dpZHRoLFxyXG4gICAgICBheGlzWExhYmVsV2lkdGhcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgeyB4MSwgeDIgfSA9IHRoaXMueENvb3JkaW5hdGVzKFxyXG4gICAgICBzZXJpZXNJbmRleCxcclxuICAgICAgc2VyaWVJdGVtRGF0YUluZGV4LFxyXG4gICAgICBjaGFydEJhclBsb3RBcmVhLFxyXG4gICAgICBiYXJXaWR0aCxcclxuICAgICAgc3BhY2VCZXR3ZWVuQmFycyxcclxuICAgICAgYXhpc1hMYWJlbFdpZHRoXHJcbiAgICApO1xyXG4gICAgY29uc3QgeyB5MSwgeTIgfSA9IHRoaXMueUNvb3JkaW5hdGVzKG1pbk1heFNlcmllc1ZhbHVlcywgc3ZnUGxvdHRpbmdBcmVhSGVpZ2h0LCBzZXJpZVZhbHVlKTtcclxuXHJcbiAgICByZXR1cm4gWydNJywgeDEsIHkyLCAnTCcsIHgyLCB5MiwgJ0wnLCB4MiwgeTEsICdMJywgeDEsIHkxLCAneiddLmpvaW4oJyAnKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2FsY3VsYXRlRWxlbWVudHNNZWFzdXJlbWVudHMoXHJcbiAgICBzdmdXaWR0aDogUG9DaGFydENvbnRhaW5lclNpemVbJ3N2Z1dpZHRoJ10sXHJcbiAgICBheGlzWExhYmVsV2lkdGg6IFBvQ2hhcnRDb250YWluZXJTaXplWydheGlzWExhYmVsV2lkdGgnXVxyXG4gICkge1xyXG4gICAgLy8gRnJhw6fDo28gZGFzIHPDqXJpZXMgZW0gcmVsYcOnw6NvIMOgIGxhcmd1cmEgZGEgY2F0ZWdvcmlhLiBJbmNyZW1lbnRhICsgMiBuYSBleHRlbnPDo28gZGFzIHPDqXJpZXMgcG9pcyBzZSB0cmF0YSBkYSDDoXJlYSBkZSBtYXJnZW0gZW50cmUgYXMgY2F0ZWdvcmlhcy5cclxuICAgIGNvbnN0IGNoYXJ0QmFyUGxvdEFyZWEgPSBzdmdXaWR0aCAtIGF4aXNYTGFiZWxXaWR0aDtcclxuICAgIGNvbnN0IGNhdGVnb3J5V2lkdGggPSBjaGFydEJhclBsb3RBcmVhIC8gdGhpcy5zZXJpZXNHcmVhdGVyTGVuZ3RoO1xyXG4gICAgY29uc3QgY29sdW1uRnJhY3Rpb24gPSBjYXRlZ29yeVdpZHRoIC8gKHRoaXMuc2VyaWVzLmxlbmd0aCArIDIpO1xyXG5cclxuICAgIC8vIMOBcmVhIGVudHJlIGFzIGNvbHVuYXM6IHJldG9ybmEgemVybyBzZSBob3V2ZXIgYXBlbmFzIHVtYSBzw6lyaWUuXHJcbiAgICBjb25zdCBzcGFjZUJldHdlZW5CYXJzID0gdGhpcy5zZXJpZXMubGVuZ3RoID4gMSA/IGNvbHVtbkZyYWN0aW9uIC8gKHRoaXMuc2VyaWVzLmxlbmd0aCArIDIpIDogMDtcclxuXHJcbiAgICAvLyBTdWJ0cmFpIGEgZnJhw6fDo28gZGFzIHPDqXJpZXMgcGVsbyBlc3Bhw6dvIGVudHJlIGFzIGNvbHVuYXMuXHJcbiAgICBjb25zdCBiYXJXaWR0aCA9IGNvbHVtbkZyYWN0aW9uIC0gKHNwYWNlQmV0d2VlbkJhcnMgKiAodGhpcy5zZXJpZXMubGVuZ3RoIC0gMSkpIC8gKHRoaXMuc2VyaWVzLmxlbmd0aCArIDIpO1xyXG5cclxuICAgIHJldHVybiB7IGNoYXJ0QmFyUGxvdEFyZWEsIGJhcldpZHRoLCBzcGFjZUJldHdlZW5CYXJzIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHhDb29yZGluYXRlcyhcclxuICAgIHNlcmllc0luZGV4OiBudW1iZXIsXHJcbiAgICBzZXJpZUl0ZW1EYXRhSW5kZXg6IG51bWJlcixcclxuICAgIGNoYXJ0QmFyUGxvdEFyZWE6IG51bWJlcixcclxuICAgIGJhcldpZHRoOiBudW1iZXIsXHJcbiAgICBzcGFjZUJldHdlZW5CYXJzOiBudW1iZXIsXHJcbiAgICBheGlzWExhYmVsV2lkdGg6IFBvQ2hhcnRDb250YWluZXJTaXplWydheGlzWExhYmVsV2lkdGgnXVxyXG4gICkge1xyXG4gICAgLy8gQSDDoXJlYSBsYXRlcmFsIGVudHJlIGEgY29sdW5hIGUgYSBsaW5oYSBkbyBlaXhvIFkgZG8gZ3JpZCBzZXLDoSBzZW1wcmUgZXF1aXZhbGVudGUgw6AgbGFyZ3VyYSBkYSBjb2x1bmEuXHJcbiAgICBjb25zdCBzcGFjZUJldHdlZW5BeGlzQW5kQmFycyA9IGJhcldpZHRoO1xyXG4gICAgY29uc3QgeFJhdGlvID0gc2VyaWVJdGVtRGF0YUluZGV4IC8gdGhpcy5zZXJpZXNHcmVhdGVyTGVuZ3RoO1xyXG5cclxuICAgIGNvbnN0IHgxID0gTWF0aC5yb3VuZChcclxuICAgICAgYXhpc1hMYWJlbFdpZHRoICtcclxuICAgICAgICBjaGFydEJhclBsb3RBcmVhICogeFJhdGlvICtcclxuICAgICAgICBzcGFjZUJldHdlZW5BeGlzQW5kQmFycyArXHJcbiAgICAgICAgYmFyV2lkdGggKiBzZXJpZXNJbmRleCArXHJcbiAgICAgICAgc3BhY2VCZXR3ZWVuQmFycyAqIHNlcmllc0luZGV4XHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHgyID0gTWF0aC5yb3VuZCh4MSArIGJhcldpZHRoKTtcclxuXHJcbiAgICByZXR1cm4geyB4MSwgeDIgfTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgeUNvb3JkaW5hdGVzKG1pbk1heFNlcmllc1ZhbHVlczogUG9DaGFydE1pbk1heFZhbHVlcywgc3ZnUGxvdHRpbmdBcmVhSGVpZ2h0OiBudW1iZXIsIHNlcmllVmFsdWU6IG51bWJlcikge1xyXG4gICAgY29uc3QgeyBtaW5WYWx1ZSB9ID0gbWluTWF4U2VyaWVzVmFsdWVzO1xyXG4gICAgY29uc3QgbWluVmFsdWVQZXJjZW50YWdlID0gdGhpcy5tYXRoc1NlcnZpY2UuZ2V0U2VyaWVQZXJjZW50YWdlKG1pbk1heFNlcmllc1ZhbHVlcywgbWluVmFsdWUgPCAwID8gMCA6IG1pblZhbHVlKTtcclxuICAgIGNvbnN0IHkxID0gTWF0aC5yb3VuZChcclxuICAgICAgc3ZnUGxvdHRpbmdBcmVhSGVpZ2h0IC0gc3ZnUGxvdHRpbmdBcmVhSGVpZ2h0ICogbWluVmFsdWVQZXJjZW50YWdlICsgUG9DaGFydFBsb3RBcmVhUGFkZGluZ1RvcFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCB5UmF0aW8gPSB0aGlzLm1hdGhzU2VydmljZS5nZXRTZXJpZVBlcmNlbnRhZ2UobWluTWF4U2VyaWVzVmFsdWVzLCBzZXJpZVZhbHVlKTtcclxuICAgIGNvbnN0IHkyID0gTWF0aC5yb3VuZChzdmdQbG90dGluZ0FyZWFIZWlnaHQgLSBzdmdQbG90dGluZ0FyZWFIZWlnaHQgKiB5UmF0aW8gKyBQb0NoYXJ0UGxvdEFyZWFQYWRkaW5nVG9wKTtcclxuXHJcbiAgICByZXR1cm4geyB5MSwgeTIgfTtcclxuICB9XHJcbn1cclxuIiwiPHN2ZzpnPlxyXG4gIDxzdmc6ZyAqbmdGb3I9XCJsZXQgaXRlbSBvZiBzZXJpZXNQYXRoc0Nvb3JkaW5hdGVzOyBsZXQgaSA9IGluZGV4OyB0cmFja0J5OiB0cmFja0J5XCJcclxuICAgIFtjbGFzc109XCIncG8tY2hhcnQtYmFyLWdyb3VwLScgKyBpXCJcclxuICA+XHJcbiAgICA8IS0tIFNFUklFUyBQQVRIUyAtLT5cclxuICAgIDxzdmc6ZyBwby1jaGFydC1iYXItcGF0aFxyXG4gICAgICBbYXR0ci5rZXldPVwiJ3BvLWNoYXJ0LWJhci1wYXRoLScgKyBpXCJcclxuICAgICAgW3AtY29sb3JdPVwiaXRlbVswXT8uY29sb3JcIiBcclxuICAgICAgW3AtY29vcmRpbmF0ZXNdPVwiaXRlbVwiXHJcbiAgICAgIFtwLXRvb2x0aXAtcG9zaXRpb25dPVwidG9vbHRpcFBvc2l0aW9uXCJcclxuICAgICAgKHAtYmFyLWNsaWNrKT1cIm9uU2VyaWVCYXJDbGljaygkZXZlbnQpXCJcclxuICAgICAgKHAtYmFyLWhvdmVyKT1cIm9uU2VyaWVCYXJIb3ZlcigkZXZlbnQpXCJcclxuICAgICAgPlxyXG4gICAgICA8L3N2ZzpnPlxyXG4gIDwvc3ZnOmc+XHJcbjwvc3ZnOmc+Il19